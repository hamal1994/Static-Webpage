{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t// Require module\n\t__webpack_require__(1);\n\t__webpack_require__(3);\n\t\n\tvar oTabs = window.oTabs = __webpack_require__(19);\n\t\n\t//const oExpanderObjects = window.oExpanderObjects = oExpander.init(document.body, {})\n\t\n\tvar tabsObjects = window.tabsObjects = oTabs.init(document.body, {\n\t\tdisablefocus: false\n\t});\n\t\n\t// Wait until the page has loaded\n\tif (document.readyState === 'interactive' || document.readyState === 'complete') {\n\t\tdocument.dispatchEvent(new CustomEvent('o.DOMContentLoaded'));\n\t}\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t// Dispatch a custom event that will tell all required modules to initialise\n\t\tdocument.dispatchEvent(new CustomEvent('o.DOMContentLoaded'));\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\tvar define = false;\n\t\n\t/*global module*/\n\t\n\t/**\n\t * Detect IE 8 through injected conditional comments:\n\t * no UA detection, no need for conditional compilation or JS check\n\t * @return {Bool} true if the browser is IE 8\n\t */\n\tvar isIE8 = (function () {\n\t\tvar b = document.createElement('B');\n\t\tvar docElem = document.documentElement;\n\t\tvar isIE = undefined;\n\t\n\t\tb.innerHTML = '<!--[if IE 8]><b id=\"ie8test\"></b><![endif]-->';\n\t\tdocElem.appendChild(b);\n\t\tisIE = !!document.getElementById('ie8test');\n\t\tdocElem.removeChild(b);\n\t\treturn isIE;\n\t})();\n\t\n\t/**\n\t * Grab grid properties\n\t * @return {Object} layout names and gutter widths\n\t */\n\tfunction getGridProperties() {\n\t\treturn getGridFromDoc('after');\n\t}\n\t\n\t/**\n\t * Get all layout sizes\n\t * @return {Object} layout names and sizes\n\t */\n\tfunction getGridBreakpoints() {\n\t\treturn getGridFromDoc('before');\n\t}\n\t\n\t/**\n\t * Grab grid properties surfaced in html:after and html:before's content\n\t * @param {String} position Whether to get all properties in :before, or current properties in :after\n\t * @return {Object} layout names and gutter widths\n\t */\n\tfunction getGridFromDoc(position) {\n\t\t// Contained in a try/catch as it should not error if o-grid styles are not (deliberately or accidentally) loaded\n\t\t// e.g. o-tracking will always try to read this property, but the page is not obliged to use o-grid for layout\n\t\ttry {\n\t\t\tvar gridProperties = window.getComputedStyle(document.documentElement, ':' + position).getPropertyValue('content');\n\t\t\t// Firefox computes: \"{\\\"foo\\\": \\\"bar\\\"}\"\n\t\t\t// We want readable JSON: {\"foo\": \"bar\"}\n\t\t\tgridProperties = gridProperties.replace(/'/g, '').replace(/\\\\/g, '').replace(/^\"/, '').replace(/\"$/, '');\n\t\t\treturn JSON.parse(gridProperties);\n\t\t} catch (e) {\n\t\t\treturn {};\n\t\t}\n\t}\n\t\n\t/**\n\t * Grab the current layout\n\t * @return {String} Layout name\n\t */\n\tfunction getCurrentLayout() {\n\t\tif (isIE8) {\n\t\t\treturn 'L';\n\t\t}\n\t\n\t\treturn getGridProperties().layout;\n\t}\n\t\n\t/**\n\t * Grab the current space between columns\n\t * @return {String} Gutter width in pixels\n\t */\n\tfunction getCurrentGutter() {\n\t\tif (isIE8) {\n\t\t\treturn '20px';\n\t\t}\n\t\n\t\treturn getGridProperties().gutter;\n\t}\n\t\n\t/**\n\t * This sets MediaQueryListeners on all the o-grid breakpoints\n\t * and fires a `o-grid.layoutChange` event on layout change.\n\t */\n\tfunction enableLayoutChangeEvents() {\n\t\t// Create a map containing all breakpoints exposed via html:before\n\t\tvar gridLayouts = getGridBreakpoints();\n\t\tif (gridLayouts.hasOwnProperty('layouts')) {\n\t\t\t(function () {\n\t\t\t\tvar layouts = gridLayouts.layouts;\n\t\t\t\tvar breakpoints = new Map(Object.keys(layouts).map(function (key) {\n\t\t\t\t\treturn [key, layouts[key]];\n\t\t\t\t}));\n\t\t\t\tvar decr1 = function decr1(val) {\n\t\t\t\t\treturn Number(val.replace('px', '') - 1) + 'px';\n\t\t\t\t};\n\t\n\t\t\t\t// Generate media queries for each\n\t\t\t\tbreakpoints.forEach(function (width, size) {\n\t\t\t\t\tvar queries = [];\n\t\t\t\t\tif (size === 'S') {\n\t\t\t\t\t\tqueries.push('(max-width: ' + width + ')');\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('M')) + ')');\n\t\t\t\t\t} else if (size === 'M') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('L')) + ')');\n\t\t\t\t\t} else if (size === 'L') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ') and (max-width: ' + decr1(breakpoints.get('XL')) + ')');\n\t\t\t\t\t} else if (size === 'XL') {\n\t\t\t\t\t\tqueries.push('(min-width: ' + width + ')');\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// matchMedia listener handler: Dispatch `o-grid.layoutChange` event if a match\n\t\t\t\t\tvar handleMQChange = function handleMQChange(mql) {\n\t\t\t\t\t\tif (mql.matches) {\n\t\t\t\t\t\t\twindow.dispatchEvent(new CustomEvent('o-grid.layoutChange', {\n\t\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\t\tlayout: size\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// Create a new listener for each layout\n\t\t\t\t\tqueries.forEach(function (mq) {\n\t\t\t\t\t\tvar mql = window.matchMedia(mq);\n\t\t\t\t\t\tmql.addListener(handleMQChange);\n\t\t\t\t\t\thandleMQChange(mql);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})();\n\t\t} else {\n\t\t\tconsole.error('To enable grid layout change events, include oGridSurfaceLayoutSizes in your Sass');\n\t\t}\n\t}\n\t\n\texports['default'] = {\n\t\tgetCurrentLayout: getCurrentLayout,\n\t\tgetCurrentGutter: getCurrentGutter,\n\t\tgetGridBreakpoints: getGridBreakpoints,\n\t\tenableLayoutChangeEvents: enableLayoutChangeEvents\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(4);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require,module*/\n\t\n\tvar oHierarchicalNav = __webpack_require__(5);\n\tvar constructAll = function constructAll() {\n\t\toHierarchicalNav.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t\n\tmodule.exports = oHierarchicalNav;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require,module,document,HTMLElement*/\n\t\n\tvar SquishyList = __webpack_require__(6);\n\tvar DomDelegate = __webpack_require__(8);\n\tvar oViewport = __webpack_require__(10);\n\tvar Nav = __webpack_require__(15);\n\t\n\tfunction ResponsiveNav(rootEl) {\n\t\n\t\tvar rootDelegate = undefined;\n\t\tvar nav = undefined;\n\t\tvar contentFilterEl = undefined;\n\t\tvar contentFilter = undefined;\n\t\tvar moreEl = undefined;\n\t\tvar moreListEl = undefined;\n\t\tvar clonedIdPrefix = 'o-hierarchical-nav__cloned-id-';\n\t\tvar prefixedNodes = [];\n\t\n\t\t// Check if element is a controller of another DOM element\n\t\tfunction isMegaDropdownControl(el) {\n\t\t\treturn el && el.hasAttribute('aria-controls');\n\t\t}\n\t\n\t\t// On resize, apply o-squishy-list, and, if it has a sub-level dom, populate more list\n\t\tfunction resize() {\n\t\t\tnav.resize();\n\t\n\t\t\tif (contentFilter) {\n\t\t\t\tcontentFilter.squish();\n\t\t\t\tif (!isMegaDropdownControl(moreEl)) {\n\t\t\t\t\tpopulateMoreList(contentFilter.getHiddenItems());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Empty the more list\n\t\tfunction emptyMoreList() {\n\t\t\tif (moreListEl) {\n\t\t\t\tmoreListEl.innerHTML = '';\n\t\t\t}\n\t\t}\n\t\n\t\t// Get the information from the element and create a new li tag with the element's text to append more list\n\t\tfunction addItemToMoreList(text, href) {\n\t\t\tvar itemEl = document.createElement('li');\n\t\t\tvar aEl = document.createElement('a');\n\t\n\t\t\tif (typeof aEl.textContent !== 'undefined') {\n\t\t\t\taEl.textContent = text;\n\t\t\t} else {\n\t\t\t\taEl.innerText = text;\n\t\t\t}\n\t\n\t\t\taEl.href = href;\n\t\t\titemEl.appendChild(aEl);\n\t\t\tmoreListEl.appendChild(itemEl);\n\t\t}\n\t\n\t\tfunction cloneItemToMoreList(el) {\n\t\t\tvar cloneEl = el.cloneNode(true);\n\t\t\t// remove the attributes that are only applicable to higher level\n\t\t\tcloneEl.removeAttribute('data-priority');\n\t\t\tcloneEl.removeAttribute('aria-hidden');\n\t\t\tcloneEl.removeAttribute('data-o-hierarchical-nav-is-cloneable');\n\t\t\t// recurse through children and amend any id values to maintain uniqueness\n\t\t\tprefixIds(el);\n\t\n\t\t\t// increase level of nested menus\n\t\t\tincrementMenuDepths(cloneEl);\n\t\n\t\t\tmoreListEl.appendChild(cloneEl);\n\t\t}\n\t\n\t\tfunction resetIds() {\n\t\t\tvar nextNode = undefined;\n\t\t\twhile (prefixedNodes.length > 0) {\n\t\t\t\tnextNode = prefixedNodes.pop();\n\t\t\t\tnextNode.setAttribute('id', nextNode.getAttribute('id').replace(clonedIdPrefix, ''));\n\t\t\t}\n\t\t}\n\t\n\t\tfunction incrementMenuDepths(el) {\n\t\t\t// data-o-hierarchical-nav-level attribute is incremented by one for each\n\t\t\t// of the children recursively. Modifies elements in place, assumes\n\t\t\t// cloned element to be passed in.\n\t\t\tvar child = undefined;\n\t\t\tif (el.hasChildNodes()) {\n\t\t\t\tvar children = el.childNodes;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchild = children[i];\n\t\t\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\t\t\tif (child.hasAttribute('data-o-hierarchical-nav-level')) {\n\t\t\t\t\t\t\t// increment nav-level when attribute present\n\t\t\t\t\t\t\tvar origNavLevel = parseInt(child.getAttribute('data-o-hierarchical-nav-level'), 10);\n\t\t\t\t\t\t\tvar updatedNavLevel = (isNaN(origNavLevel) ? 0 : origNavLevel) + 1;\n\t\t\t\t\t\t\tchild.setAttribute('data-o-hierarchical-nav-level', updatedNavLevel);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementMenuDepths(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction prefixIds(el) {\n\t\t\t// id's are prefixed to ensure that any id based functionality uses the visible element\n\t\t\t// for example a 'label' tag with a 'for' attribute will not find the correct input it\n\t\t\t// relates to as it uses the first matching id in the document\n\t\t\tvar child = undefined;\n\t\t\tif (el.hasChildNodes()) {\n\t\t\t\tvar children = el.childNodes;\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchild = children[i];\n\t\t\t\t\tif (child instanceof HTMLElement) {\n\t\t\t\t\t\tif (child.hasAttribute('id')) {\n\t\t\t\t\t\t\tprefixedNodes.push(child); // store to make the cleanup more performant\n\t\t\t\t\t\t\tchild.setAttribute('id', clonedIdPrefix + child.getAttribute('id'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprefixIds(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// For every hidden item, add it to the more list\n\t\tfunction populateMoreList(hiddenEls) {\n\t\t\temptyMoreList();\n\t\t\tresetIds();\n\t\n\t\t\tfor (var c = 0, l = hiddenEls.length; c < l; c++) {\n\t\t\t\tvar aEl = hiddenEls[c].querySelector('a');\n\t\t\t\tvar ulEl = hiddenEls[c].querySelector('ul');\n\t\n\t\t\t\tif (hiddenEls[c].hasAttribute('data-o-hierarchical-nav-is-cloneable')) {\n\t\t\t\t\tcloneItemToMoreList(hiddenEls[c]);\n\t\t\t\t} else {\n\t\t\t\t\tvar aText = typeof aEl.textContent !== 'undefined' ? aEl.textContent : aEl.innerText;\n\t\t\t\t\taddItemToMoreList(aText, aEl.href, ulEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// If all elements are hidden, add the all modifier, if not, the some modifier\n\t\tfunction setMoreElClass(remainingItems) {\n\t\t\tif (!moreEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (remainingItems === 0) {\n\t\t\t\tmoreEl.classList.add('o-hierarchical-nav__more--all');\n\t\t\t\tmoreEl.classList.remove('o-hierarchical-nav__more--some');\n\t\t\t} else {\n\t\t\t\tmoreEl.classList.add('o-hierarchical-nav__more--some');\n\t\t\t\tmoreEl.classList.remove('o-hierarchical-nav__more--all');\n\t\t\t}\n\t\t}\n\t\n\t\t// When there's an o-squishy-list change, collapse all elements and run the setMoreElClass method with number of non-hidden elements\n\t\tfunction contentFilterChangeHandler(ev) {\n\t\t\tif (ev.target === contentFilterEl && ev.detail.hiddenItems.length > 0) {\n\t\t\t\tnav.collapseAll();\n\t\t\t\tsetMoreElClass(ev.detail.remainingItems.length);\n\t\t\t}\n\t\t}\n\t\n\t\t// If more button is clicked, populate it\n\t\tfunction navExpandHandler(ev) {\n\t\t\tif (ev.target === moreEl) {\n\t\t\t\tpopulateMoreList(contentFilter.getHiddenItems());\n\t\t\t}\n\t\t}\n\t\n\t\tfunction init() {\n\t\t\tif (!rootEl) {\n\t\t\t\trootEl = document.body;\n\t\t\t} else if (!(rootEl instanceof HTMLElement)) {\n\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t}\n\t\n\t\t\tnav = new Nav(rootEl);\n\t\t\trootDelegate = new DomDelegate(rootEl);\n\t\t\tcontentFilterEl = rootEl.querySelector('ul');\n\t\t\tmoreEl = rootEl.querySelector('[data-more]');\n\t\n\t\t\tif (contentFilterEl) {\n\t\t\t\tcontentFilter = new SquishyList(contentFilterEl, { filterOnResize: false });\n\t\t\t}\n\t\n\t\t\t// If there's a more element, add a ul tag where hidden elements will be appended\n\t\t\tif (moreEl) {\n\t\t\t\tmoreEl.setAttribute('aria-hidden', 'true');\n\t\n\t\t\t\tif (!isMegaDropdownControl(moreEl)) {\n\t\t\t\t\tmoreListEl = document.createElement('ul');\n\t\t\t\t\tmoreListEl.setAttribute('data-o-hierarchical-nav-level', '2');\n\t\t\t\t\tmoreEl.appendChild(moreListEl);\n\t\t\t\t\trootDelegate.on('oLayers.new', navExpandHandler);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\trootDelegate.on('oSquishyList.change', contentFilterChangeHandler);\n\t\n\t\t\tvar bodyDelegate = new DomDelegate(document.body);\n\t\n\t\t\t// Force a resize when it loads, in case it loads on a smaller screen\n\t\t\tresize();\n\t\n\t\t\toViewport.listenTo('resize');\n\t\t\tbodyDelegate.on('oViewport.resize', resize);\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\tprefixedNodes = [];\n\t\t\trootDelegate.destroy();\n\t\t\trootEl.removeAttribute('data-o-hierarchical-nav--js');\n\t\t}\n\t\n\t\tinit();\n\t\n\t\tthis.resize = resize;\n\t\tthis.destroy = destroy;\n\t}\n\t\n\t// Initializes all nav elements in the page or whatever element is passed to it\n\tResponsiveNav.init = function (el) {\n\t\tif (!el) {\n\t\t\tel = document.body;\n\t\t} else if (!(el instanceof HTMLElement)) {\n\t\t\tel = document.querySelector(el);\n\t\t}\n\t\n\t\tvar navEls = el.querySelectorAll('[data-o-component=\"o-hierarchical-nav\"]');\n\t\tvar responsiveNavs = [];\n\t\n\t\tfor (var c = 0, l = navEls.length; c < l; c++) {\n\t\t\tif (!navEls[c].hasAttribute('data-o-hierarchical-nav--js')) {\n\t\t\t\t// If it's a vertical nav, we don't need all the responsive methods\n\t\t\t\tif (navEls[c].getAttribute('data-o-hierarchical-nav-orientiation') === 'vertical') {\n\t\t\t\t\tresponsiveNavs.push(new Nav(navEls[c]));\n\t\t\t\t} else {\n\t\t\t\t\tresponsiveNavs.push(new ResponsiveNav(navEls[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn responsiveNavs;\n\t};\n\t\n\tmodule.exports = ResponsiveNav;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(7);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar define = false;\n\t\n\tvar SquishyList = (function () {\n\t\tfunction SquishyList(rootEl, opts) {\n\t\t\t_classCallCheck(this, SquishyList);\n\t\n\t\t\tthis.element = rootEl;\n\t\t\tthis.moreWidth = 0;\n\t\t\tthis.options = opts || { filterOnResize: true };\n\t\n\t\t\tthis.getPrioritySortedChildNodeEls();\n\t\t\tthis.moreEl = this.element.querySelector('[data-more]');\n\t\t\tif (this.moreEl) {\n\t\t\t\tthis.showEl(this.moreEl);\n\t\t\t\tthis.moreWidth = this.moreEl.offsetWidth;\n\t\t\t\tthis.hideEl(this.moreEl);\n\t\t\t}\n\t\t\tthis.squish();\n\t\t\tif (this.options.filterOnResize) {\n\t\t\t\twindow.addEventListener('resize', this.resizeHandler.bind(this), false);\n\t\t\t}\n\t\n\t\t\tthis.dispatchCustomEvent('oSquishyList.ready');\n\t\t}\n\t\n\t\t_createClass(SquishyList, [{\n\t\t\tkey: 'dispatchCustomEvent',\n\t\t\tvalue: function dispatchCustomEvent(name, data) {\n\t\t\t\tif (document.createEvent && this.element.dispatchEvent) {\n\t\t\t\t\tvar _event = document.createEvent('Event');\n\t\t\t\t\t_event.initEvent(name, true, true);\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\t_event.detail = data;\n\t\t\t\t\t}\n\t\t\t\t\tthis.element.dispatchEvent(_event);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getItemEls',\n\t\t\tvalue: function getItemEls() {\n\t\t\t\tvar itemEls = [];\n\t\t\t\tvar childNodeEl = undefined;\n\t\n\t\t\t\tfor (var c = 0, l = this.element.childNodes.length; c < l; c++) {\n\t\t\t\t\tchildNodeEl = this.element.childNodes[c];\n\t\n\t\t\t\t\t// Make it flexible so that other product and modules can manually hide elements and o-squishy-list won't add it to it's list\n\t\t\t\t\tif (childNodeEl.nodeType === 1 && !childNodeEl.hasAttribute('data-more') && !childNodeEl.hasAttribute('data-o-squishy-list--ignore')) {\n\t\t\t\t\t\titemEls.push(childNodeEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn itemEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showEl',\n\t\t\tvalue: function showEl(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tif (el) {\n\t\t\t\t\tel.removeAttribute('aria-hidden');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hideEl',\n\t\t\tvalue: function hideEl(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tif (el) {\n\t\t\t\t\tel.setAttribute('aria-hidden', 'true');\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getElPriority',\n\t\t\tvalue: function getElPriority(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\treturn parseInt(el.getAttribute('data-priority'), 10);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getPrioritySortedChildNodeEls',\n\t\t\tvalue: function getPrioritySortedChildNodeEls() {\n\t\t\t\tthis.allItemEls = this.getItemEls();\n\t\t\t\tthis.prioritySortedItemEls = [];\n\t\t\t\tvar unprioritisedItemEls = [];\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tvar thisItemEl = this.allItemEls[c];\n\t\t\t\t\tvar thisItemPriority = this.getElPriority(thisItemEl);\n\t\t\t\t\tif (isNaN(thisItemPriority)) {\n\t\t\t\t\t\tunprioritisedItemEls.push(thisItemEl);\n\t\t\t\t\t} else if (thisItemPriority >= 0) {\n\t\t\t\t\t\tif (!Array.isArray(this.prioritySortedItemEls[thisItemPriority])) {\n\t\t\t\t\t\t\tthis.prioritySortedItemEls[thisItemPriority] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.prioritySortedItemEls[thisItemPriority].push(thisItemEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (unprioritisedItemEls.length > 0) {\n\t\t\t\t\tthis.prioritySortedItemEls.push(unprioritisedItemEls);\n\t\t\t\t}\n\t\t\t\tthis.prioritySortedItemEls = this.prioritySortedItemEls.filter(function (v) {\n\t\t\t\t\treturn v !== undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showAllItems',\n\t\t\tvalue: function showAllItems() {\n\t\t\t\tthis.hiddenItemEls = [];\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tthis.showEl(this.allItemEls[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hideItems',\n\t\t\tvalue: function hideItems(els) {\n\t\t\t\t// We want highest priority items to be at the beginning of the array\n\t\t\t\tfor (var i = els.length - 1; i > -1; i--) {\n\t\t\t\t\tthis.hiddenItemEls.unshift(els[i]);\n\t\t\t\t\tthis.hideEl(els[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getVisibleContentWidth',\n\t\t\tvalue: function getVisibleContentWidth() {\n\t\t\t\tvar visibleItemsWidth = 0;\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tif (!this.allItemEls[c].hasAttribute('aria-hidden')) {\n\t\t\t\t\t\tvisibleItemsWidth += this.allItemEls[c].offsetWidth; // Needs to take into account margins too\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn visibleItemsWidth;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'doesContentFit',\n\t\t\tvalue: function doesContentFit() {\n\t\t\t\treturn this.getVisibleContentWidth() <= this.element.clientWidth;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getHiddenItems',\n\t\t\tvalue: function getHiddenItems() {\n\t\t\t\treturn this.hiddenItemEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getRemainingItems',\n\t\t\tvalue: function getRemainingItems() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\treturn this.allItemEls.filter(function (el) {\n\t\t\t\t\treturn _this.hiddenItemEls.indexOf(el) === -1;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'squish',\n\t\t\tvalue: function squish() {\n\t\t\t\tthis.showAllItems();\n\t\t\t\tif (this.doesContentFit()) {\n\t\t\t\t\tthis.hideEl(this.moreEl);\n\t\t\t\t} else {\n\t\t\t\t\tfor (var p = this.prioritySortedItemEls.length - 1; p >= 0; p--) {\n\t\t\t\t\t\tthis.hideItems(this.prioritySortedItemEls[p]);\n\t\t\t\t\t\tif (this.getVisibleContentWidth() + this.moreWidth <= this.element.clientWidth) {\n\t\t\t\t\t\t\tthis.showEl(this.moreEl);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.dispatchCustomEvent('oSquishyList.change', {\n\t\t\t\t\thiddenItems: this.getHiddenItems(),\n\t\t\t\t\tremainingItems: this.getRemainingItems()\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'resizeHandler',\n\t\t\tvalue: function resizeHandler() {\n\t\t\t\tclearTimeout(this.debounceTimeout);\n\t\t\t\tthis.debounceTimeout = setTimeout(this.squish.bind(this), 50);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\tfor (var c = 0, l = this.allItemEls.length; c < l; c++) {\n\t\t\t\t\tthis.allItemEls[c].removeAttribute('aria-hidden');\n\t\t\t\t}\n\t\t\t\twindow.removeEventListener('resize', this.resizeHandler, false);\n\t\t\t\tthis.element.removeAttribute('data-o-squishy-list-js');\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'init',\n\t\t\tvalue: function init(el, opts) {\n\t\t\t\tif (!el) {\n\t\t\t\t\tel = document.body;\n\t\t\t\t}\n\t\t\t\tif (!(el instanceof HTMLElement)) {\n\t\t\t\t\tel = document.querySelector(el);\n\t\t\t\t}\n\t\t\t\tif (/\\bo-squishy-list\\b/.test(el.getAttribute('data-o-component'))) {\n\t\t\t\t\treturn new SquishyList(el, opts);\n\t\t\t\t}\n\t\t\t\treturn [].map.call(el.querySelectorAll('[data-o-component=\"o-squishy-list\"]'), function (el) {\n\t\t\t\t\treturn new SquishyList(el, opts);\n\t\t\t\t});\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn SquishyList;\n\t})();\n\t\n\texports['default'] = SquishyList;\n\t\n\tvar constructAll = function constructAll() {\n\t\tSquishyList.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\t\n\tif (typeof window !== 'undefined') {\n\t\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(9);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*jshint browser:true, node:true*/\n\t\n\t'use strict';\n\t\n\tmodule.exports = Delegate;\n\t\n\t/**\n\t * DOM event delegator\n\t *\n\t * The delegator will listen\n\t * for events that bubble up\n\t * to the root node.\n\t *\n\t * @constructor\n\t * @param {Node|string} [root] The root node or a selector string matching the root node\n\t */\n\tfunction Delegate(root) {\n\t\n\t  /**\n\t   * Maintain a map of listener\n\t   * lists, keyed by event name.\n\t   *\n\t   * @type Object\n\t   */\n\t  this.listenerMap = [{}, {}];\n\t  if (root) {\n\t    this.root(root);\n\t  }\n\t\n\t  /** @type function() */\n\t  this.handle = Delegate.prototype.handle.bind(this);\n\t}\n\t\n\t/**\n\t * Start listening for events\n\t * on the provided DOM element\n\t *\n\t * @param  {Node|string} [root] The root node or a selector string matching the root node\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.root = function (root) {\n\t  var listenerMap = this.listenerMap;\n\t  var eventType;\n\t\n\t  // Remove master event listeners\n\t  if (this.rootElement) {\n\t    for (eventType in listenerMap[1]) {\n\t      if (listenerMap[1].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, true);\n\t      }\n\t    }\n\t    for (eventType in listenerMap[0]) {\n\t      if (listenerMap[0].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, false);\n\t      }\n\t    }\n\t  }\n\t\n\t  // If no root or root is not\n\t  // a dom node, then remove internal\n\t  // root reference and exit here\n\t  if (!root || !root.addEventListener) {\n\t    if (this.rootElement) {\n\t      delete this.rootElement;\n\t    }\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * The root node at which\n\t   * listeners are attached.\n\t   *\n\t   * @type Node\n\t   */\n\t  this.rootElement = root;\n\t\n\t  // Set up master event listeners\n\t  for (eventType in listenerMap[1]) {\n\t    if (listenerMap[1].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, true);\n\t    }\n\t  }\n\t  for (eventType in listenerMap[0]) {\n\t    if (listenerMap[0].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, false);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} eventType\n\t * @returns boolean\n\t */\n\tDelegate.prototype.captureForType = function (eventType) {\n\t  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n\t};\n\t\n\t/**\n\t * Attach a handler to one\n\t * event for all elements\n\t * that match the selector,\n\t * now or in the future\n\t *\n\t * The handler function receives\n\t * three arguments: the DOM event\n\t * object, the node that matched\n\t * the selector while the event\n\t * was bubbling and a reference\n\t * to itself. Within the handler,\n\t * 'this' is equal to the second\n\t * argument.\n\t *\n\t * The node that actually received\n\t * the event can be accessed via\n\t * 'event.target'.\n\t *\n\t * @param {string} eventType Listen for these events\n\t * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t * @param {boolean} [useCapture] see 'useCapture' in <https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener>\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.on = function (eventType, selector, handler, useCapture) {\n\t  var root, listenerMap, matcher, matcherParam;\n\t\n\t  if (!eventType) {\n\t    throw new TypeError('Invalid event type: ' + eventType);\n\t  }\n\t\n\t  // handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // Fallback to sensible defaults\n\t  // if useCapture not set\n\t  if (useCapture === undefined) {\n\t    useCapture = this.captureForType(eventType);\n\t  }\n\t\n\t  if (typeof handler !== 'function') {\n\t    throw new TypeError('Handler must be a type of Function');\n\t  }\n\t\n\t  root = this.rootElement;\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t\n\t  // Add master handler for type if not created yet\n\t  if (!listenerMap[eventType]) {\n\t    if (root) {\n\t      root.addEventListener(eventType, this.handle, useCapture);\n\t    }\n\t    listenerMap[eventType] = [];\n\t  }\n\t\n\t  if (!selector) {\n\t    matcherParam = null;\n\t\n\t    // COMPLEX - matchesRoot needs to have access to\n\t    // this.rootElement, so bind the function to this.\n\t    matcher = matchesRoot.bind(this);\n\t\n\t    // Compile a matcher for the given selector\n\t  } else if (/^[a-z]+$/i.test(selector)) {\n\t      matcherParam = selector;\n\t      matcher = matchesTag;\n\t    } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n\t      matcherParam = selector.slice(1);\n\t      matcher = matchesId;\n\t    } else {\n\t      matcherParam = selector;\n\t      matcher = matches;\n\t    }\n\t\n\t  // Add to the list of listeners\n\t  listenerMap[eventType].push({\n\t    selector: selector,\n\t    handler: handler,\n\t    matcher: matcher,\n\t    matcherParam: matcherParam\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove an event handler\n\t * for elements that match\n\t * the selector, forever\n\t *\n\t * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.off = function (eventType, selector, handler, useCapture) {\n\t  var i, listener, listenerMap, listenerList, singleEventType;\n\t\n\t  // Handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // If useCapture not set, remove\n\t  // all event listeners\n\t  if (useCapture === undefined) {\n\t    this.off(eventType, selector, handler, true);\n\t    this.off(eventType, selector, handler, false);\n\t    return this;\n\t  }\n\t\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t  if (!eventType) {\n\t    for (singleEventType in listenerMap) {\n\t      if (listenerMap.hasOwnProperty(singleEventType)) {\n\t        this.off(singleEventType, selector, handler);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  listenerList = listenerMap[eventType];\n\t  if (!listenerList || !listenerList.length) {\n\t    return this;\n\t  }\n\t\n\t  // Remove only parameter matches\n\t  // if specified\n\t  for (i = listenerList.length - 1; i >= 0; i--) {\n\t    listener = listenerList[i];\n\t\n\t    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n\t      listenerList.splice(i, 1);\n\t    }\n\t  }\n\t\n\t  // All listeners removed\n\t  if (!listenerList.length) {\n\t    delete listenerMap[eventType];\n\t\n\t    // Remove the main handler\n\t    if (this.rootElement) {\n\t      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Handle an arbitrary event.\n\t *\n\t * @param {Event} event\n\t */\n\tDelegate.prototype.handle = function (event) {\n\t  var i,\n\t      l,\n\t      type = event.type,\n\t      root,\n\t      phase,\n\t      listener,\n\t      returned,\n\t      listenerList = [],\n\t      target,\n\t      /** @const */EVENTIGNORE = 'ftLabsDelegateIgnore';\n\t\n\t  if (event[EVENTIGNORE] === true) {\n\t    return;\n\t  }\n\t\n\t  target = event.target;\n\t\n\t  // Hardcode value of Node.TEXT_NODE\n\t  // as not defined in IE8\n\t  if (target.nodeType === 3) {\n\t    target = target.parentNode;\n\t  }\n\t\n\t  root = this.rootElement;\n\t\n\t  phase = event.eventPhase || (event.target !== event.currentTarget ? 3 : 2);\n\t\n\t  switch (phase) {\n\t    case 1:\n\t      //Event.CAPTURING_PHASE:\n\t      listenerList = this.listenerMap[1][type];\n\t      break;\n\t    case 2:\n\t      //Event.AT_TARGET:\n\t      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n\t      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n\t      break;\n\t    case 3:\n\t      //Event.BUBBLING_PHASE:\n\t      listenerList = this.listenerMap[0][type];\n\t      break;\n\t  }\n\t\n\t  // Need to continuously check\n\t  // that the specific list is\n\t  // still populated in case one\n\t  // of the callbacks actually\n\t  // causes the list to be destroyed.\n\t  l = listenerList.length;\n\t  while (target && l) {\n\t    for (i = 0; i < l; i++) {\n\t      listener = listenerList[i];\n\t\n\t      // Bail from this loop if\n\t      // the length changed and\n\t      // no more listeners are\n\t      // defined between i and l.\n\t      if (!listener) {\n\t        break;\n\t      }\n\t\n\t      // Check for match and fire\n\t      // the event if there's one\n\t      //\n\t      // TODO:MCG:20120117: Need a way\n\t      // to check if event#stopImmediatePropagation\n\t      // was called. If so, break both loops.\n\t      if (listener.matcher.call(target, listener.matcherParam, target)) {\n\t        returned = this.fire(event, target, listener);\n\t      }\n\t\n\t      // Stop propagation to subsequent\n\t      // callbacks if the callback returned\n\t      // false\n\t      if (returned === false) {\n\t        event[EVENTIGNORE] = true;\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    }\n\t\n\t    // TODO:MCG:20120117: Need a way to\n\t    // check if event#stopPropagation\n\t    // was called. If so, break looping\n\t    // through the DOM. Stop if the\n\t    // delegation root has been reached\n\t    if (target === root) {\n\t      break;\n\t    }\n\t\n\t    l = listenerList.length;\n\t    target = target.parentElement;\n\t  }\n\t};\n\t\n\t/**\n\t * Fire a listener on a target.\n\t *\n\t * @param {Event} event\n\t * @param {Node} target\n\t * @param {Object} listener\n\t * @returns {boolean}\n\t */\n\tDelegate.prototype.fire = function (event, target, listener) {\n\t  return listener.handler.call(target, event, target);\n\t};\n\t\n\t/**\n\t * Check whether an element\n\t * matches a generic selector.\n\t *\n\t * @type function()\n\t * @param {string} selector A CSS selector\n\t */\n\tvar matches = (function (el) {\n\t  if (!el) return;\n\t  var p = el.prototype;\n\t  return p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;\n\t})(Element);\n\t\n\t/**\n\t * Check whether an element\n\t * matches a tag selector.\n\t *\n\t * Tags are NOT case-sensitive,\n\t * except in XML (and XML-based\n\t * languages such as XHTML).\n\t *\n\t * @param {string} tagName The tag name to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesTag(tagName, element) {\n\t  return tagName.toLowerCase() === element.tagName.toLowerCase();\n\t}\n\t\n\t/**\n\t * Check whether an element\n\t * matches the root.\n\t *\n\t * @param {?String} selector In this case this is always passed through as null and not used\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesRoot(selector, element) {\n\t  /*jshint validthis:true*/\n\t  if (this.rootElement === window) return element === document;\n\t  return this.rootElement === element;\n\t}\n\t\n\t/**\n\t * Check whether the ID of\n\t * the element in 'this'\n\t * matches the given ID.\n\t *\n\t * IDs are case-sensitive.\n\t *\n\t * @param {string} id The ID to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesId(id, element) {\n\t  return id === element.id;\n\t}\n\t\n\t/**\n\t * Short hand for off()\n\t * and root(), ie both\n\t * with no parameters\n\t *\n\t * @return void\n\t */\n\tDelegate.prototype.destroy = function () {\n\t  this.off();\n\t  this.root();\n\t};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(11);\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t// let debug;\n\tvar utils = __webpack_require__(12);\n\tvar throttle = utils.throttle;\n\tvar debounce = utils.debounce;\n\t\n\tvar listeners = {};\n\tvar intervals = {\n\t\tresize: 100,\n\t\torientation: 100,\n\t\tvisibility: 100,\n\t\tscroll: 100\n\t};\n\t\n\tfunction setThrottleInterval(eventType, interval) {\n\t\tif (typeof arguments[0] === 'number') {\n\t\t\tsetThrottleInterval('scroll', arguments[0]);\n\t\t\tsetThrottleInterval('resize', arguments[1]);\n\t\t\tsetThrottleInterval('orientation', arguments[2]);\n\t\t\tsetThrottleInterval('visibility', arguments[3]);\n\t\t} else if (interval) {\n\t\t\tintervals[eventType] = interval;\n\t\t}\n\t}\n\t\n\tfunction listenToResize() {\n\t\tif (listeners.resize) {\n\t\t\treturn;\n\t\t}\n\t\tvar eventType = 'resize';\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('resize', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.resize);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.resize = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToOrientation() {\n\t\n\t\tif (listeners.orientation) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = 'orientationchange';\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('orientation', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\torientation: utils.getOrientation(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.orientation);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.orientation = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToVisibility() {\n\t\n\t\tif (listeners.visibility) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = utils.detectVisiblityAPI().eventType;\n\t\tvar handler = debounce(function (ev) {\n\t\t\tutils.broadcast('visibility', {\n\t\t\t\thidden: utils.getVisibility(),\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.visibility);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\n\t\tlisteners.visibility = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenToScroll() {\n\t\n\t\tif (listeners.scroll) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar eventType = 'scroll';\n\t\tvar handler = throttle(function (ev) {\n\t\t\tvar scrollPos = utils.getScrollPosition();\n\t\t\tutils.broadcast('scroll', {\n\t\t\t\tviewport: utils.getSize(),\n\t\t\t\tscrollHeight: scrollPos.height,\n\t\t\t\tscrollLeft: scrollPos.left,\n\t\t\t\tscrollTop: scrollPos.top,\n\t\t\t\tscrollWidth: scrollPos.width,\n\t\t\t\toriginalEvent: ev\n\t\t\t});\n\t\t}, intervals.scroll);\n\t\n\t\twindow.addEventListener(eventType, handler);\n\t\tlisteners.scroll = {\n\t\t\teventType: eventType,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t\n\tfunction listenTo(eventType) {\n\t\tif (eventType === 'resize' || eventType === 'all') {\n\t\t\tlistenToResize();\n\t\t}\n\t\n\t\tif (eventType === 'scroll' || eventType === 'all') {\n\t\t\tlistenToScroll();\n\t\t}\n\t\n\t\tif (eventType === 'orientation' || eventType === 'all') {\n\t\t\tlistenToOrientation();\n\t\t}\n\t\n\t\tif (eventType === 'visibility' || eventType === 'all') {\n\t\t\tlistenToVisibility();\n\t\t}\n\t}\n\t\n\tfunction stopListeningTo(eventType) {\n\t\tif (eventType === 'all') {\n\t\t\tObject.keys(listeners).forEach(stopListeningTo);\n\t\t} else if (listeners[eventType]) {\n\t\t\twindow.removeEventListener(listeners[eventType].eventType, listeners[eventType].handler);\n\t\t\tdelete listeners[eventType];\n\t\t}\n\t}\n\t\n\tmodule.exports = {\n\t\tdebug: function debug() {\n\t\t\t// debug = true;\n\t\t\tutils.debug();\n\t\t},\n\t\tlistenTo: listenTo,\n\t\tstopListeningTo: stopListeningTo,\n\t\tsetThrottleInterval: setThrottleInterval,\n\t\tgetOrientation: utils.getOrientation,\n\t\tgetSize: utils.getSize,\n\t\tgetScrollPosition: utils.getScrollPosition,\n\t\tgetVisibility: utils.getVisibility\n\t};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/* jshint devel: true */\n\tvar oUtils = __webpack_require__(13);\n\t\n\tvar _debug = undefined;\n\t\n\tfunction broadcast(eventType, data, target) {\n\t\ttarget = target || document.body;\n\t\n\t\tif (_debug) {\n\t\t\tconsole.log('o-viewport', eventType, data);\n\t\t}\n\t\n\t\ttarget.dispatchEvent(new CustomEvent('oViewport.' + eventType, {\n\t\t\tdetail: data,\n\t\t\tbubbles: true\n\t\t}));\n\t}\n\t\n\tfunction getHeight(ignoreScrollbars) {\n\t\treturn ignoreScrollbars ? document.documentElement.clientHeight : Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n\t}\n\t\n\tfunction getWidth(ignoreScrollbars) {\n\t\treturn ignoreScrollbars ? document.documentElement.clientWidth : Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n\t}\n\t\n\tfunction getSize(ignoreScrollbars) {\n\t\treturn {\n\t\t\theight: module.exports.getHeight(ignoreScrollbars),\n\t\t\twidth: module.exports.getWidth(ignoreScrollbars)\n\t\t};\n\t}\n\t\n\tfunction getScrollPosition() {\n\t\tvar de = document.documentElement;\n\t\tvar db = document.body;\n\t\n\t\t// adapted from https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY\n\t\tvar isCSS1Compat = (document.compatMode || '') === 'CSS1Compat';\n\t\n\t\tvar ieX = isCSS1Compat ? de.scrollLeft : db.scrollLeft;\n\t\tvar ieY = isCSS1Compat ? de.scrollTop : db.scrollTop;\n\t\treturn {\n\t\t\theight: db.scrollHeight,\n\t\t\twidth: db.scrollWidth,\n\t\t\tleft: window.pageXOffset || window.scrollX || ieX,\n\t\t\ttop: window.pageYOffset || window.scrollY || ieY\n\t\t};\n\t}\n\t\n\tfunction getOrientation() {\n\t\tvar orientation = window.screen.orientation || window.screen.mozOrientation || window.screen.msOrientation || undefined;\n\t\tif (orientation) {\n\t\t\treturn typeof orientation === 'string' ? orientation.split('-')[0] : orientation.type.split('-')[0];\n\t\t} else if (window.matchMedia) {\n\t\t\treturn window.matchMedia('(orientation: portrait)').matches ? 'portrait' : 'landscape';\n\t\t} else {\n\t\t\treturn getHeight() >= getWidth() ? 'portrait' : 'landscape';\n\t\t}\n\t}\n\t\n\tfunction detectVisiblityAPI() {\n\t\tvar hiddenName = undefined;\n\t\tvar eventType = undefined;\n\t\tif (typeof document.hidden !== 'undefined') {\n\t\t\thiddenName = 'hidden';\n\t\t\teventType = 'visibilitychange';\n\t\t} else if (typeof document.mozHidden !== 'undefined') {\n\t\t\thiddenName = 'mozHidden';\n\t\t\teventType = 'mozvisibilitychange';\n\t\t} else if (typeof document.msHidden !== 'undefined') {\n\t\t\thiddenName = 'msHidden';\n\t\t\teventType = 'msvisibilitychange';\n\t\t} else if (typeof document.webkitHidden !== 'undefined') {\n\t\t\thiddenName = 'webkitHidden';\n\t\t\teventType = 'webkitvisibilitychange';\n\t\t}\n\t\n\t\treturn {\n\t\t\thiddenName: hiddenName,\n\t\t\teventType: eventType\n\t\t};\n\t}\n\t\n\tfunction getVisibility() {\n\t\tvar hiddenName = detectVisiblityAPI().hiddenName;\n\t\treturn document[hiddenName];\n\t}\n\t\n\tmodule.exports = {\n\t\tdebug: function debug() {\n\t\t\t_debug = true;\n\t\t},\n\t\tbroadcast: broadcast,\n\t\tgetWidth: getWidth,\n\t\tgetHeight: getHeight,\n\t\tgetSize: getSize,\n\t\tgetScrollPosition: getScrollPosition,\n\t\tgetVisibility: getVisibility,\n\t\tgetOrientation: getOrientation,\n\t\tdetectVisiblityAPI: detectVisiblityAPI,\n\t\tdebounce: oUtils.debounce,\n\t\tthrottle: oUtils.throttle\n\t};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(14);\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tvar define = false;\n\t\n\t/**\n\t*\n\t* Debounces function so it is only called after n milliseconds\n\t* without it not being called\n\t*\n\t* @example\n\t* Utils.debounce(myFunction() {}, 100);\n\t*\n\t* @param {Function} func - Function to be debounced\n\t* @param {number} wait - Time in miliseconds\n\t*\n\t* @returns {Function} - Debounced function\n\t*/\n\tfunction debounce(func, wait) {\n\t\tvar timeout = undefined;\n\t\treturn function () {\n\t\t\tvar _this = this;\n\t\n\t\t\tvar args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tfunc.apply(_this, args);\n\t\t\t};\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t}\n\t\n\t/**\n\t*\n\t* Throttle function so it is only called once every n milliseconds\n\t*\n\t* @example\n\t* Utils.throttle(myFunction() {}, 100);\n\t*\n\t* @param {Function} func - Function to be throttled\n\t* @param {number} wait - Time in miliseconds\n\t*\n\t* @returns {Function} - Throttled function\n\t*/\n\tfunction throttle(func, wait) {\n\t\tvar timeout = undefined;\n\t\treturn function () {\n\t\t\tvar _this2 = this;\n\t\n\t\t\tif (timeout) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tfunc.apply(_this2, args);\n\t\t\t};\n\t\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t}\n\t\n\texports.debounce = debounce;\n\texports.throttle = throttle;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t\n\tvar DomDelegate = __webpack_require__(8);\n\tvar oDom = __webpack_require__(16);\n\tvar utils = __webpack_require__(18);\n\t\n\tfunction Nav(rootEl) {\n\t\n\t\tvar bodyDelegate = new DomDelegate(document.body);\n\t\tvar rootDelegate = new DomDelegate(rootEl);\n\t\n\t\t// Get sub-level element\n\t\tfunction getChildListEl(el) {\n\t\t\treturn el.querySelector('ul');\n\t\t}\n\t\n\t\t// Check if element has sub-level nav\n\t\tfunction hasChildList(el) {\n\t\t\treturn !!getChildListEl(el);\n\t\t}\n\t\n\t\t// Get controlled element\n\t\tfunction getMegaDropdownEl(itemEl) {\n\t\t\tif (itemEl.hasAttribute('aria-controls')) {\n\t\t\t\treturn document.getElementById(itemEl.getAttribute('aria-controls'));\n\t\t\t}\n\t\t}\n\t\n\t\t// Check if element is a controller of another DOM element\n\t\tfunction isControlEl(el) {\n\t\t\treturn !!(getChildListEl(el) || getMegaDropdownEl(el));\n\t\t}\n\t\n\t\t// Check if element has been expanded\n\t\tfunction isExpanded(el) {\n\t\t\treturn el.getAttribute('aria-expanded') === 'true';\n\t\t}\n\t\n\t\t// Check if a certain element is inside the root nav\n\t\tfunction isElementInsideNav(el) {\n\t\t\tvar expandedLevel1El = rootEl.querySelector('[data-o-hierarchical-nav-level=\"1\"] > [aria-expanded=\"true\"]');\n\t\t\tvar expandedMegaDropdownEl = undefined;\n\t\t\tvar allLevel1Els = undefined;\n\t\n\t\t\tif (expandedLevel1El) {\n\t\t\t\texpandedMegaDropdownEl = getMegaDropdownEl(expandedLevel1El);\n\t\t\t\tif (expandedMegaDropdownEl && expandedMegaDropdownEl.contains(el)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tallLevel1Els = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"1\"] > li');\n\t\n\t\t\tfor (var c = 0, l = allLevel1Els.length; c < l; c++) {\n\t\t\t\tif (allLevel1Els[c].contains(el)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// Get the level a nav is in\n\t\tfunction getLevel(el) {\n\t\t\treturn parseInt(el.parentNode.getAttribute('data-o-hierarchical-nav-level'), 10);\n\t\t}\n\t\n\t\t// Check if a level 2 nav will fit in the window\n\t\tfunction level2ListFitsInWindow(l2El) {\n\t\t\treturn l2El.getBoundingClientRect().right < window.innerWidth;\n\t\t}\n\t\n\t\t// Check if an element will have enough space to its right\n\t\tfunction elementFitsToRight(el1, el2) {\n\t\t\treturn el1.getBoundingClientRect().right + el2.offsetWidth < window.innerWidth;\n\t\t}\n\t\n\t\t// Depending on if an element fits to its right or not, change its class to apply correct css\n\t\tfunction positionChildListEl(parentEl, childEl) {\n\t\t\tparentEl.classList.remove('o-hierarchical-nav--align-right');\n\t\t\tparentEl.classList.remove('o-hierarchical-nav__outside-right');\n\t\t\tparentEl.classList.remove('o-hierarchical-nav--left');\n\t\n\t\t\tif (!childEl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (getLevel(parentEl) === 1) {\n\t\t\t\tif (!level2ListFitsInWindow(childEl)) {\n\t\t\t\t\tparentEl.classList.add('o-hierarchical-nav--align-right');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (elementFitsToRight(parentEl, childEl)) {\n\t\t\t\t\tparentEl.classList.add('o-hierarchical-nav__outside-right');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Hide an element\n\t\tfunction hideEl(el) {\n\t\t\tif (el) {\n\t\t\t\tel.setAttribute('aria-hidden', 'true');\n\t\t\t}\n\t\t}\n\t\n\t\t// Display an element\n\t\tfunction showEl(el) {\n\t\t\tif (el) {\n\t\t\t\tel.removeAttribute('aria-hidden');\n\t\t\t}\n\t\t}\n\t\n\t\t// Collapse all items from a certain node list\n\t\tfunction collapseAll(nodeList) {\n\t\t\tif (!nodeList) {\n\t\t\t\tnodeList = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"1\"] > li[aria-expanded=true]');\n\t\t\t}\n\t\n\t\t\tutils.nodeListToArray(nodeList).forEach(function (childListItemEl) {\n\t\t\t\tif (isExpanded(childListItemEl)) {\n\t\t\t\t\tcollapseItem(childListItemEl);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t// Set an element as not expanded, and if it has children, do the same to them\n\t\tfunction collapseItem(itemEl) {\n\t\t\titemEl.setAttribute('aria-expanded', 'false');\n\t\n\t\t\tif (utils.isIE8) {\n\t\t\t\titemEl.classList.add('forceIErepaint');\n\t\t\t\titemEl.classList.remove('forceIErepaint');\n\t\t\t}\n\t\n\t\t\tif (hasChildList(itemEl)) {\n\t\t\t\tcollapseAll(getChildListEl(itemEl).children);\n\t\t\t}\n\t\n\t\t\thideEl(getMegaDropdownEl(itemEl));\n\t\t\tdispatchCloseEvent(itemEl);\n\t\t}\n\t\n\t\t// Get same level items and collapse them\n\t\tfunction collapseSiblingItems(itemEl) {\n\t\t\tvar listLevel = oDom.getClosestMatch(itemEl, 'ul').getAttribute('data-o-hierarchical-nav-level');\n\t\t\tvar listItemEls = rootEl.querySelectorAll('[data-o-hierarchical-nav-level=\"' + listLevel + '\"] > li[aria-expanded=\"true\"]');\n\t\n\t\t\tfor (var c = 0, l = listItemEls.length; c < l; c++) {\n\t\t\t\tcollapseItem(listItemEls[c]);\n\t\t\t}\n\t\t}\n\t\n\t\t// Expand a nav item\n\t\tfunction expandItem(itemEl) {\n\t\t\tcollapseSiblingItems(itemEl);\n\t\t\titemEl.setAttribute('aria-expanded', 'true');\n\t\t\tpositionChildListEl(itemEl, getChildListEl(itemEl));\n\t\t\tshowEl(getMegaDropdownEl(itemEl));\n\t\t\tdispatchExpandEvent(itemEl);\n\t\t}\n\t\n\t\t// Helper method to dispatch o-layers new event\n\t\tfunction dispatchExpandEvent(itemEl) {\n\t\t\tutils.dispatchCustomEvent(itemEl, 'oLayers.new', { 'zIndex': 10, 'el': itemEl });\n\t\t}\n\t\n\t\t// Helper method to dispatch o-layers close event\n\t\tfunction dispatchCloseEvent(itemEl) {\n\t\t\tutils.dispatchCustomEvent(itemEl, 'oLayers.close', { 'zIndex': 10, 'el': itemEl });\n\t\t}\n\t\n\t\t// Handle clicks ourselved by expanding or collapsing selected element\n\t\tfunction handleClick(ev) {\n\t\t\tvar itemEl = oDom.getClosestMatch(ev.target, 'li');\n\t\n\t\t\tif (itemEl && isControlEl(itemEl)) {\n\t\t\t\tev.preventDefault();\n\t\n\t\t\t\tif (!isExpanded(itemEl)) {\n\t\t\t\t\texpandItem(itemEl);\n\t\t\t\t} else {\n\t\t\t\t\tcollapseItem(itemEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Position a level 3 nav and deeper\n\t\tfunction positionExpandedLevels() {\n\t\t\t// find deepest expanded menu element\n\t\t\tvar openMenus = rootEl.querySelectorAll('li[aria-expanded=\"true\"] > ul[data-o-hierarchical-nav-level]');\n\t\n\t\t\t// find the deepest level currently open\n\t\t\tvar deepestLevel = -1;\n\t\t\tfor (var c = 0, l = openMenus.length; c < l; c++) {\n\t\t\t\tdeepestLevel = Math.max(deepestLevel, openMenus[c].getAttribute(\"data-o-hierarchical-nav-level\"));\n\t\t\t}\n\t\n\t\t\t// start checking space / collapsing where needed\n\t\t\tfor (var l = 2; l <= deepestLevel; l++) {\n\t\t\t\tvar openLevelParentEl = rootEl.querySelector('[data-o-hierarchical-nav-level=\"' + l + '\"] > [aria-expanded=\"true\"]');\n\t\t\t\tvar openLevelChildEl = rootEl.querySelector('[data-o-hierarchical-nav-level=\"' + l + '\"] > [aria-expanded=\"true\"] > ul');\n\t\n\t\t\t\tif (openLevelParentEl && openLevelChildEl) {\n\t\t\t\t\tpositionChildListEl(openLevelParentEl, openLevelChildEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// Position level 3 and below on resize\n\t\tfunction resize() {\n\t\t\tpositionExpandedLevels();\n\t\t}\n\t\n\t\t// Set all tabIndexes of a tags to 0\n\t\tfunction setTabIndexes() {\n\t\t\tvar aEls = rootEl.querySelectorAll('li > a');\n\t\n\t\t\tfor (var c = 0, l = aEls.length; c < l; c++) {\n\t\t\t\tif (!aEls[c].hasAttribute('href')) {\n\t\t\t\t\tif (aEls[c].tabIndex === 0) {\n\t\t\t\t\t\t// Don't override tabIndex if something else has set it, but otherwise set it to zero to make it focusable.\n\t\t\t\t\t\taEls[c].tabIndex = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction setLayersContext() {\n\t\t\t// We'll use the body as the default context\n\t\t\tbodyDelegate.on('oLayers.new', function (e) {\n\t\t\t\tif (!isElementInsideNav(e.detail.el)) {\n\t\t\t\t\tcollapseAll();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction init() {\n\t\t\tif (!rootEl) {\n\t\t\t\trootEl = document.body;\n\t\t\t} else if (!(rootEl instanceof HTMLElement)) {\n\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t}\n\t\n\t\t\trootEl.setAttribute('data-o-hierarchical-nav--js', '');\n\t\t\tsetTabIndexes();\n\t\t\tsetLayersContext();\n\t\t\trootDelegate.on('click', handleClick);\n\t\t\trootDelegate.on('keyup', function (ev) {\n\t\t\t\t// Pressing enter key on anchors without @href won't trigger a click event\n\t\t\t\tif (!ev.target.hasAttribute('href') && ev.keyCode === 13 && isElementInsideNav(ev.target)) {\n\t\t\t\t\thandleClick(ev);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// Collapse all elements if the user clicks outside the nav\n\t\t\tbodyDelegate.on('click', function (ev) {\n\t\t\t\tif (!isElementInsideNav(ev.target)) {\n\t\t\t\t\tcollapseAll();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction destroy() {\n\t\t\trootDelegate.destroy();\n\t\t\tbodyDelegate.destroy();\n\t\t\trootEl.removeAttribute('data-o-hierarchical-nav--js');\n\t\t}\n\t\n\t\tinit();\n\t\n\t\tthis.resize = resize;\n\t\tthis.collapseAll = collapseAll;\n\t\tthis.destroy = destroy;\n\t}\n\t\n\tmodule.exports = Nav;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(17);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global exports*/\n\t\n\tfunction getClosestMatch(el, selector) {\n\t\twhile (el) {\n\t\t\tif (el.matches(selector)) {\n\t\t\t\treturn el;\n\t\t\t} else {\n\t\t\t\tel = el.parentElement;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tfunction getIndex(el) {\n\t\tvar i = 0;\n\t\tif (el && typeof el === 'object' && el.nodeType === 1) {\n\t\t\twhile (el.previousSibling) {\n\t\t\t\tel = el.previousSibling;\n\t\t\t\tif (el.nodeType === 1) {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t}\n\t\n\texports.getClosestMatch = getClosestMatch;\n\texports.getIndex = getIndex;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global exports*/\n\t\n\t// Helper function that converts a list of elements into an array\n\tfunction nodeListToArray(nl) {\n\t\treturn [].map.call(nl, function (element) {\n\t\t\treturn element;\n\t\t});\n\t}\n\t\n\t// Helper function to dispatch events\n\tfunction dispatchCustomEvent(el, name, data) {\n\t\tif (document.createEvent && el.dispatchEvent) {\n\t\t\tvar _event = document.createEvent('Event');\n\t\t\t_event.initEvent(name, true, true);\n\t\n\t\t\tif (data) {\n\t\t\t\t_event.detail = data;\n\t\t\t}\n\t\n\t\t\tel.dispatchEvent(_event);\n\t\t}\n\t}\n\t\n\tfunction isIE8() {\n\t\tvar b = document.createElement('B');\n\t\tvar docElem = document.documentElement;\n\t\tvar isIE = undefined;\n\t\n\t\tb.innerHTML = '<!--[if IE 8]><b id=\"ie8test\"></b><![endif]-->';\n\t\tdocElem.appendChild(b);\n\t\tisIE = !!document.getElementById('ie8test');\n\t\tdocElem.removeChild(b);\n\t\treturn isIE;\n\t}\n\t\n\texports.isIE8 = isIE8();\n\texports.nodeListToArray = nodeListToArray;\n\texports.dispatchCustomEvent = dispatchCustomEvent;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(20);\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tvar define = false;\n\t\n\t/*global require, module*/\n\t\n\tvar Tabs = __webpack_require__(21);\n\t\n\tvar constructAll = function constructAll() {\n\t\tTabs.init();\n\t\tdocument.removeEventListener('o.DOMContentLoaded', constructAll);\n\t};\n\t\n\tdocument.addEventListener('o.DOMContentLoaded', constructAll);\n\t\n\tmodule.exports = Tabs;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar define = false;\n\t\n\t/*global module, require*/\n\tvar oDom = __webpack_require__(16);\n\t\n\tvar Tabs = (function () {\n\t\tfunction Tabs(rootEl, config) {\n\t\t\t_classCallCheck(this, Tabs);\n\t\n\t\t\tthis.rootEl = rootEl;\n\t\t\tthis.rootEl.setAttribute('data-o-tabs--js', '');\n\t\n\t\t\tthis.updateUrl = rootEl.getAttribute('data-o-tabs-update-url') !== null;\n\t\t\tthis.selectedTabIndex = -1;\n\t\n\t\t\tthis.tabEls = this.rootEl.querySelectorAll('[role=tab]');\n\t\t\tthis.tabEls = [].slice.call(this.tabEls).filter(this.tabHasValidUrl);\n\t\t\tthis.tabpanelEls = this.getTabPanelEls(this.tabEls);\n\t\n\t\t\tthis.boundClickHandler = this.clickHandler.bind(this);\n\t\t\tthis.rootEl.addEventListener('click', this.boundClickHandler, false);\n\t\t\tthis.boundKeyPressHandler = this.keyPressHandler.bind(this);\n\t\t\tthis.rootEl.addEventListener('keypress', this.boundKeyPressHandler, false);\n\t\t\tthis.boundHashChangeHandler = this.hashChangeHandler.bind(this);\n\t\t\twindow.addEventListener('hashchange', this.boundHashChangeHandler, false);\n\t\n\t\t\tif (!config) {\n\t\t\t\tconfig = {};\n\t\t\t\tArray.prototype.forEach.call(this.rootEl.attributes, function (attr) {\n\t\t\t\t\tif (attr.name.includes('data-o-tabs')) {\n\t\t\t\t\t\t// Remove the unnecessary part of the string the first\n\t\t\t\t\t\t// time this is run for each attribute\n\t\t\t\t\t\tvar key = attr.name.replace('data-o-tabs-', '');\n\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// If it's a JSON, a boolean or a number, we want it stored like that,\n\t\t\t\t\t\t\t// and not as a string. We also replace all ' with \" so JSON strings\n\t\t\t\t\t\t\t// are parsed correctly\n\t\t\t\t\t\t\tconfig[key] = JSON.parse(attr.value.replace(/\\'/g, '\"'));\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconfig[key] = attr.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tthis.config = config;\n\t\t\tthis.dispatchCustomEvent('ready', {\n\t\t\t\ttabs: this\n\t\t\t});\n\t\t\tthis.selectTab(this.getSelectedTabIndex());\n\t\t}\n\t\n\t\t_createClass(Tabs, [{\n\t\t\tkey: 'getTabTargetId',\n\t\t\tvalue: function getTabTargetId(tabEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tvar linkEls = tabEl.getElementsByTagName('a');\n\t\t\t\treturn linkEls && linkEls[0] ? linkEls[0].getAttribute('href').replace('#', '') : '';\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabPanelEls',\n\t\t\tvalue: function getTabPanelEls(tabEls) {\n\t\t\t\tvar panelEls = [];\n\t\n\t\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\t\tvar _didIteratorError = false;\n\t\t\t\tvar _iteratorError = undefined;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator = tabEls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\t\tvar tab = _step.value;\n\t\n\t\t\t\t\t\tvar tabTargetId = this.getTabTargetId(tab);\n\t\t\t\t\t\tvar targetEl = document.getElementById(tabTargetId);\n\t\n\t\t\t\t\t\tif (targetEl) {\n\t\t\t\t\t\t\ttab.setAttribute('aria-controls', tabTargetId);\n\t\t\t\t\t\t\ttab.setAttribute('tabindex', '0');\n\t\n\t\t\t\t\t\t\tvar label = tab.getElementsByTagName('a')[0];\n\t\t\t\t\t\t\tvar labelId = tabTargetId + '-label';\n\t\t\t\t\t\t\tlabel.setAttribute('tabindex', '-1');\n\t\t\t\t\t\t\tlabel.id = labelId;\n\t\t\t\t\t\t\ttargetEl.setAttribute('aria-labelledby', labelId);\n\t\t\t\t\t\t\ttargetEl.setAttribute('role', 'tabpanel');\n\t\t\t\t\t\t\ttargetEl.setAttribute('tabindex', '0');\n\t\t\t\t\t\t\tpanelEls.push(targetEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t_iteratorError = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator['return']) {\n\t\t\t\t\t\t\t_iterator['return']();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn panelEls;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabElementFromHash',\n\t\t\tvalue: function getTabElementFromHash() {\n\t\t\t\tvar tabLink = this.rootEl.querySelector('[href=\"' + location.hash + '\"]');\n\t\t\t\treturn tabLink && tabLink.parentNode ? tabLink.parentNode : null;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getTabIndexFromElement',\n\t\t\tvalue: function getTabIndexFromElement(el) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\treturn oDom.getIndex(el);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getSelectedTabElement',\n\t\t\tvalue: function getSelectedTabElement() {\n\t\t\t\treturn this.rootEl.querySelector('[aria-selected=true]');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getSelectedTabIndex',\n\t\t\tvalue: function getSelectedTabIndex() {\n\t\t\t\tvar selectedTabElement = this.updateUrl && location.hash ? this.getTabElementFromHash() : this.getSelectedTabElement();\n\t\t\t\treturn selectedTabElement ? this.getTabIndexFromElement(selectedTabElement) : 0;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'isValidTab',\n\t\t\tvalue: function isValidTab(index) {\n\t\t\t\treturn !isNaN(index) && index >= 0 && index < this.tabEls.length;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hidePanel',\n\t\t\tvalue: function hidePanel(panelEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tpanelEl.setAttribute('aria-expanded', 'false');\n\t\t\t\tpanelEl.setAttribute('aria-hidden', 'true');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'showPanel',\n\t\t\tvalue: function showPanel(panelEl, disableFocus) {\n\t\t\t\tpanelEl.setAttribute('aria-expanded', 'true');\n\t\t\t\tpanelEl.setAttribute('aria-hidden', 'false');\n\t\n\t\t\t\t// Remove the focus ring for sighted users\n\t\t\t\tpanelEl.style.outline = 0;\n\t\n\t\t\t\tif (disableFocus) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// update the url to match the selected tab\n\t\t\t\tif (panelEl.id && this.updateUrl) {\n\t\t\t\t\tlocation.href = '#' + panelEl.id;\n\t\t\t\t}\n\t\n\t\t\t\t// Get current scroll position\n\t\t\t\tvar x = window.scrollX || window.pageXOffset;\n\t\t\t\tvar y = window.scrollY || window.pageYOffset;\n\t\n\t\t\t\t// Give focus to the panel for screen readers\n\t\t\t\t// This might cause the browser to scroll up or down\n\t\t\t\tpanelEl.focus();\n\t\n\t\t\t\t// Scroll back to the original position\n\t\t\t\twindow.scrollTo(x, y);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'dispatchCustomEvent',\n\t\t\tvalue: function dispatchCustomEvent(event) {\n\t\t\t\tvar data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t\t\tvar namespace = arguments.length <= 2 || arguments[2] === undefined ? 'oTabs' : arguments[2];\n\t\n\t\t\t\tthis.rootEl.dispatchEvent(new CustomEvent(namespace + '.' + event, {\n\t\t\t\t\tdetail: data,\n\t\t\t\t\tbubbles: true\n\t\t\t\t}));\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'selectTab',\n\t\t\tvalue: function selectTab(newIndex) {\n\t\t\t\tif (this.isValidTab(newIndex) && newIndex !== this.selectedTabIndex) {\n\t\t\t\t\tfor (var i = 0; i < this.tabEls.length; i++) {\n\t\t\t\t\t\tif (newIndex === i) {\n\t\t\t\t\t\t\tthis.tabEls[i].setAttribute('aria-selected', 'true');\n\t\t\t\t\t\t\tthis.showPanel(this.tabpanelEls[i], this.config.disablefocus);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.tabEls[i].setAttribute('aria-selected', 'false');\n\t\t\t\t\t\t\tthis.hidePanel(this.tabpanelEls[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.dispatchCustomEvent('tabSelect', {\n\t\t\t\t\t\ttabs: this,\n\t\t\t\t\t\tselected: newIndex,\n\t\t\t\t\t\tlastSelected: this.selectedTabIndex\n\t\t\t\t\t});\n\t\n\t\t\t\t\tthis.selectedTabIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'clickHandler',\n\t\t\tvalue: function clickHandler(ev) {\n\t\t\t\tvar tabEl = oDom.getClosestMatch(ev.target, '[role=tab]');\n\t\n\t\t\t\tif (tabEl && this.tabHasValidUrl(tabEl)) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'keyPressHandler',\n\t\t\tvalue: function keyPressHandler(ev) {\n\t\t\t\tvar tabEl = oDom.getClosestMatch(ev.target, '[role=tab]');\n\t\t\t\t// Only update if key pressed is enter key\n\t\t\t\tif (tabEl && ev.keyCode === 13 && this.tabHasValidUrl(tabEl)) {\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'hashChangeHandler',\n\t\t\tvalue: function hashChangeHandler() {\n\t\t\t\tif (!this.updateUrl) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar tabEl = this.getTabElementFromHash();\n\t\n\t\t\t\tif (tabEl) {\n\t\t\t\t\tthis.updateCurrentTab(tabEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'updateCurrentTab',\n\t\t\tvalue: function updateCurrentTab(tabEl) {\n\t\t\t\tvar index = this.getTabIndexFromElement(tabEl);\n\t\t\t\tthis.selectTab(index);\n\t\t\t\tthis.dispatchCustomEvent('event', {\n\t\t\t\t\tcategory: 'tabs',\n\t\t\t\t\taction: 'click',\n\t\t\t\t\ttab: tabEl.textContent.trim()\n\t\t\t\t}, 'oTracking');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'tabHasValidUrl',\n\t\t\tvalue: function tabHasValidUrl(tabEl) {\n\t\t\t\t// eslint-disable-line class-methods-use-this\n\t\t\t\tvar linkEls = tabEl.getElementsByTagName('a');\n\t\t\t\tif (!linkEls || !linkEls[0].hash) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn linkEls[0].pathname === location.pathname;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy() {\n\t\t\t\tthis.rootEl.removeEventListener('click', this.boundClickHandler, false);\n\t\t\t\tthis.rootEl.removeEventListener('keypress', this.boundKeyPressHandler, false);\n\t\t\t\twindow.removeEventListener('hashchange', this.boundHashChangeHandler, false);\n\t\t\t\tthis.rootEl.removeAttribute('data-o-tabs--js');\n\t\n\t\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\t\tvar _didIteratorError2 = false;\n\t\t\t\tvar _iteratorError2 = undefined;\n\t\n\t\t\t\ttry {\n\t\t\t\t\tfor (var _iterator2 = this.tabpanelEls[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\t\tvar tabPanelEl = _step2.value;\n\t\n\t\t\t\t\t\tthis.showPanel(tabPanelEl);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// unset the bound event handlers\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t_iteratorError2 = err;\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t\t\t\t\t\t\t_iterator2['return']();\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tthis.boundClickHandler = undefined;\n\t\t\t\tthis.boundKeyPressHandler = undefined;\n\t\t\t\tthis.boundHashChangeHandler = undefined;\n\t\t\t\t// Destroy ALL the things!\n\t\t\t\tthis.tabEls = undefined;\n\t\t\t\tthis.tabpanelEls = undefined;\n\t\t\t\tthis.updateUrl = undefined;\n\t\t\t\tthis.selectedTabIndex = undefined;\n\t\t\t\tthis.rootEl = undefined;\n\t\t\t\tthis.config = undefined;\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'init',\n\t\t\tvalue: function init(rootEl, config) {\n\t\t\t\tif (!rootEl) {\n\t\t\t\t\trootEl = document.body;\n\t\t\t\t}\n\t\t\t\tif (!(rootEl instanceof HTMLElement)) {\n\t\t\t\t\trootEl = document.querySelector(rootEl);\n\t\t\t\t}\n\t\n\t\t\t\tif (rootEl instanceof HTMLElement && /\\bo-tabs\\b/.test(rootEl.getAttribute('data-o-component'))) {\n\t\t\t\t\tif (!rootEl.matches('[data-o-tabs-autoconstruct=false]') && !rootEl.hasAttribute('data-o-tabs--js')) {\n\t\t\t\t\t\treturn new Tabs(rootEl, config);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (rootEl.querySelectorAll) {\n\t\t\t\t\tvar tabElements = rootEl.querySelectorAll('[data-o-component=o-tabs]:not([data-o-tabs-autoconstruct=false]):not([data-o-tabs--js])');\n\t\n\t\t\t\t\treturn Array.from(tabElements, function (tabEl) {\n\t\t\t\t\t\treturn new Tabs(tabEl, config);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Tabs;\n\t})();\n\t\n\texports['default'] = Tabs;\n\tmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=bundle.js.map"],"file":"bundle.js"}